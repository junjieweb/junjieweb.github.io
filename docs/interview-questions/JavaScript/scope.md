---
sidebar_position: 6
---

# 六、执行上下文/作用域链/闭包

## 001 - 对闭包的理解

**概念**

- 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。
- 比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。

    - 注意：必须要先调用A，B才可以访问到A里面的变量

- 用途

    - 闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。
    - 闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

**经典面试题**：循环中使用闭包解决 var 定义函数的问题

```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法

第一种是使用闭包的方式+立即执行函数

```javascript
for (var i = 1; i <= 5; i++) {
    ;(function (j) {
        setTimeout(function timer() {
            console.log(j)
        }, j * 1000)
    })(i)
}
```

- 在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的

使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入

```javascript
for (var i = 1; i <= 5; i++) {
    setTimeout(function timer(j) {
        console.log(j)
    }, i * 1000, i)
}
```

第三种就是使用 let 定义 i 了来解决问题

```javascript
for (let i = 1; i <= 5; i++) {
    setTimeout(function timer() {
        console.log(i)
    }, i * 1000)
}
```

## 002 - 对作用域、作用域链的理解

#### 作用域

- 全局作用域

    - 最外层函数和最外层函数外面定义的变量拥有全局作用域（函数本身也是一个特殊的变量，其名字就是函数名字）
    - 所有未定义直接赋值的变量自动声明为全局作用域
    - 所有window对象的属性拥有全局作用域

- 局部作用域

    - 声明在函数内部的变量，一般只有固定的代码片段可以访问到
    - 作用域是分层的，内层作用域可以访问外层作用域，反之不行

- 块级作用域

    - 使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由{ }包裹的代码片段）
    - let和const声明的变量不会有变量提升，也不可以重复声明
    - 在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部

#### 作用域链

在当前作用域中查找所需变量，如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。

**作用**: 保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。

**本质**: 一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象

## 003 - 对执行上下文的理解

在执行JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。

在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数

全局上下文：变量定义，函数声明

函数上下文：变量定义，函数声明，this，arguments

- 执行上下文类型

    - 全局执行上下文

        - 任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文

    - 函数执行上下文

        - 当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个

    - eval函数执行上下文

        - 执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用

- 执行上下文栈

    - JavaScript引擎使用执行上下文栈来管理执行上下文
    - 当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，
      引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文

    - 输出顺序Inside first function--Inside second function--Again inside first function
